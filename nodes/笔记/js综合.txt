正课:
1. 什么是JavaScript
2. 如何使用
3. 如何调试

4. ***变量
5. ***数据类型

1. 什么是JavaScript
    前端三大语言:
    HTML: 专门编写网页内容的语言
    CSS: 专门设计网页样式的语言
    JavaScript: 专门编写交互行为的语言
      什么是交互? 用户在页面执行操作
                  网页响应用户的操作，处理用户数据
                  返回处理结果

    JavaScript发展历程: 
    NetScape 1995 客户端语言 在客户端进行基本数据处理
               为什么: 节约网络流量，减少用户等待时间
           Java write once run anywhere
           起名为: JavaScript 
           客户端脚本语言，像极了Java，比Java简单
    1995 JavaScript->ECMA->ECMAScript标准->规定了核心语法
        ES标准3.1 8天   ES5标准 1天
    1996 Microsoft IE JScript
      ECMAScript:JavaScript语言的国际标准 不能直接使用
      JavaScript:NetScape参照ECMAScript标准实现的JavaScript版本
         JScript:微软参照ECMAScript标准实现的JavaScript版本
    2000 W3C DOM标准: 专门操作网页内容的一套程序标准 3天
             几乎所有浏览器100%支持
    2003 NetScape -> Mozilla -> Firefox

    总结: JavaScript=ECMAScript(核心语法 9天)
                     DOM(专门操作网页内容的程序标准 3天)
                     BOM(专门操作浏览器窗口的程序 2天)

    JavaScript特点: 
	1. 运行在客户端浏览器
        2. 解释执行: 变读取变执行，后读取的相同内容会覆盖先读取的。
	3. 弱类型
        4. 基于对象

    JavaScript的用途:
    
2. 如何使用：
    1. 如何编写: JavaScript程序就是最简单的文本
	3种方式：
            1. 在网页的script标签中
		什么是script标签: 网页中专门编写JavaScript程序的区域。
	        script可出现在页面的任何位置。
		一般2处: 1. head元素中
                         2. body元素的结尾
		何时使用: 如果一段程序只被当前页面使用

            2. 在外部js文件中
	       什么是js文件: 专门保存js程序的文件
	       何时使用: 如果一段程序，可能被多个页面共用
		如何使用: 2步:
		1. 定义.js文件，在其中编写js程序
                2. 引入.js文件:<script src="路径"></script>
	    js文件中的程序和script标签中的程序执行方式完全一样
        
	课堂练习: 
        输出一句话: 3种:
           1. alert("输出内容"): 弹出警告框
           2. document.write("输出内容"): 出现在网页的body内
              html网页
	      其实向网页中写入html内容，所有html内容给都可写入
           3. console.log("输出内容"): 向控制台输出一句话
              控制台
	      什么是控制台：专门输出数据并调试程序的窗口
	      控制台只支持js语法，不支持定制样式

        引号: js中单双引号不分

	配置快速打开浏览器:Ctrl+B
	1. 开始菜单->GoogleChrome->GoogleChrome->右键属性
	2. 复制"目标"中的全部内容
	3. Tools->Preference->点Tools->右侧下拉列表选:other browser(...)->将复制的内容，粘贴到下方文档框中->点apply
	结果: 在html文件的编辑界面，同时按Ctrl+B,在Chrome打开

    2. 如何运行:
	在浏览器软件中，包含了两个小软件： 
            内容排版引擎: 加载html内容，渲染css样式的软件
            脚本解释引擎: 读取js程序，并执行程序的软件  
正课:
1. 分支
2. ***循环

1. 分支结构: 
   什么是: 根据不同的条件执行不同的任务
   何时使用: 
   如何使用: 
    1. 1个条件，1件事。满足条件才执行。不满足就不执行
       如何实现: if(条件){操作}
    2. 1个条件，2件事。二选一执行。
       如何实现: if(条件){操作1}
                 else{操作2}
         如果满足条件，就执行 操作1
         否则就执行操作2
       强调: 必须二选一。不能都执行，也不能都不执行
    3. 多个条件，多件事，多选一执行
       如何实现: if(条件1){操作1}
                 else if(条件2){操作2}
                 else if(...){...}
                 else{默认操作}
        强调: 1. 如果前一个条件已经满足，则后续条件不再执行
              2. 如果进入后一个条件，一定说明前一个条件不满足                3. 最后一个else可省略。后果，

2. ***循环结构:
   什么是: 让程序反复执行同一代码段
   何时使用: 只要一段代码会被反复执行，就用循环
   如何使用: 三要素: 
       1. 循环条件: 保证循环可以继续执行的判断条件
       2. 循环变量: 循环条件中，用作比较的变量
	    循环变量每次都会向着不满足条件的趋势变化
       3. 循环体: 循环反复执行的代码段
   3种: 
    1. while循环: 
       var 循环变量=初始值;
       while(循环条件){
           循环体
           变化循环变量
       }
	何时使用: 如果循环变量的变化没有规律，就用while循环
      break: 中断当前结构的执行，并退出结构
      何时使用: 专门用于手动中止循环

    课堂练习: 
    随机数: Math.random() 0~1之间的小数
    公式: 在任意min~max之间取一个随机整数
        var r=parseInt(Math.random()*(max-min+1)+min);

    2. for循环:
       for(var 循环变量=初始值; 循环条件; 变化循环变量){
           循环体
       }
	何时使用: 如果循环变量的变化有规律，就用for循环
       总结: for循环其实和while循环是完全等效的！

       简写: 3种: 
          1. for的第一部分可同时声明并初始化多个变量
          2. 第三部分可同时执行多个短小的操作，每个操作之间用逗号分隔。强调: 不能改变原执行顺序
          3. 第一部分可放在for之前的外部
             第三部分可放在循环体之后
          死循环: for(;;){操作}
                 while(true){操作}
回顾:
1. ***函数
   什么是: 一项任务的步骤清单，再起一个名字
   为什么: 代码重用
   何时使用: 只要一段代码可能被反复执行，就先定义在函数中，再调用函数
   如何使用: 
       声明: 创建一个函数，封装步骤清单
         function 函数名(参数列表){
             函数体;
             return 返回值;
         }
       参数: 专门接受函数调用时必须的数据 的变量
       何时使用: 如果函数必须提供必要数据才能正常执行时
       如何定义: 不用var，可同时定义多个，用逗号分隔每个参数
       返回值: 函数的执行结果
       何时使用: 如果函数的调用者必须得到函数的执行结果时，就要定义返回值。
       如何定义: return 值;
       强调: 函数要想向内存中返回一个结果，只能用return

       调用: *找*到函数定义，并按照函数的步骤*执行*
         var 返回值=函数名(参数值列表);
        强调: 一个函数，如果不调用，绝不执行！
              参数值，会自动赋值给函数的参数变量，用于执行
        函数的本质: 函数是一个引用类型的对象
                    函数名其实是一个引用函数对象的变量
            什么是对象: 程序中保存多个数据的整体
           
   ****范围(scope 作用域): 一个变量的可用范围
       2种：全局作用域: window 
	        全局变量: 在函数外声明的变量都是全局变量
                特点: 在任何位置都可使用
            函数作用域:
                局部变量: 在函数内声明的变量和函数的参数变量都是局部变量
	        特点: 只能在函数内使用，出了函数就不能用！

            变量的使用规则: 如果局部有，就优先使用局部的
                            局部没有，才用全局的
                            如果全局没有，才报错
   ****按值传递(byValue): 
       两种情况: 1. 两变量间赋值
                 2. 将变量作为参数传入函数时
           都是将原变量中的值，复制一个副本给对方
           修改新变量的值，不影响原变量
   
   ****声明提前(hoist):
	在程序开始执行前,
	将var声明的变量和function声明的函数
	提前到当前作用域的顶部，集中声明
        但，赋值留在原地
     鄙视时: 只要发现先使用，后声明，都是在考声明提前
             都要先转化为声明提前后的样子，再执行。

正课:
1. 分支
2. ***循环
3. *数组

程序三大结构: 顺序,分支，循环
   顺序: 程序默认都是从上向下顺序执行
   分支: 根据不同的条件，执行不同的任务
   循环: 让程序反复执行相同的任务

补: 关系运算: 做比较
	>   <   >=   <=   ==   !=
       所有关系运算返回的都是bool值(true/false)
       如果返回true，说明成立；返回false，说明不成立
      何时使用: 专门用于判断条件中
      隐式转换: 默认都转为数字，再比大小
          特殊: 如果比较的*两个值都*是字符串，
		按位比较每个字符的unicode号
      特殊: 如果参与比较的值不能被转为数字，则用NaN参与比较
           结果: NaN不大于，不小于，不等于任何值
	       NaN做不等于比较时，返回true

1. ***分支: 
   正课:
1. ***DOM:
   DOM树
   查找元素
   修改元素

1. ***DOM: Document Object Model
           文档     对象   模型
   什么是: 专门操作网页内容的API
   功能: 增，删，改，查   

   鄙视题: HTML XHTML DHTML
       HTML: 专门编写网页内容的语言
       XHTML: 更严格的HTML标准
       DHTML: 一切实现网页动态效果的技术的统称
         DHTML=HTML+CSS+JS

   DOM树: 一个网页被加载进内存时
          都会先创建一个对象document，指代正在打开的网页内容
          网页中的一切内容都是document的子节点（Node）
          以document为根，所有网页中的内容组成的树形结构就是DOM树。

   查找元素: 
     1. 按照节点关系查找: 
       节点树: 包含所有内容的节点
       父子关系: parentNode  childNodes  firstChild lastChild
       兄弟关系: previousSibling  nextSibling
       强调: 看不见的空字符(空格，回车，制表符)
             除了parentNode外，都会受到空字符的干扰!
       
       元素树: 仅包含元素节点
	问题: 不包含任何文本节点
       父子关系: 
parentElementNode children firstElementChild lastElementChild
       兄弟关系: previousElementSibling  nextElementSibling

     2. 用API查找：通过HTML属性: 
       1. 按id查找元素:
         var elem=document.getElementById("id");
         返回值: 返回一个节点对象
         其实，id本身就是一个全局变量
       2. 按标签名查找: 
         var elems=elem.getElementsByTagName("标签名");
          意为: 在elem元素下，查找所有指定的“标签”
         返回值: 返回多个节点对象，组成的一个集合(像数组一样)
 	强调:getElementsByTagName不但可找到直接子节点，还会找到所有间接子节点。
       3. 按name属性查找: 
         var elems=elem.getElementsByName("name");
	  意为: 在elem元素下，查找所有name属性为指定值得元素
         返回值: 返回多个节点对象，组成的一个集合(像数组一样)
       4. 按class属性查找: 
         var elems=elem.getElementsByClassName("class")
	  意为: 在elem元素下，查找所有class属性为"class"的元素

    3. 按选择器查找:
	1. 找一个元素: 
           var elem=elem.querySelector("选择器");
	2. 找多个元素: 
           var elems=elem.querySelectorAll("选择器");

    修改：
      1. 修改元素内容: 
	elem.innerHTML: 表示开始标签到结束标签之间的html内容

      课堂练习: 
	事件:用户出发的浏览器元素状态的改变        
        单击事件: onclick
        何时定义事件: 只要希望单击元素时，指定的任务都要定义在onclick中
	如何定义: 2步
            1. 定义一个函数: 用于在事件发生时执行任务
            2. 在元素的onclick属性上调用任务函数
	强调: 事件最大的特点是只有事件触发，才执行任务

        this关键字，在事件发生时，自动获得当前触发事件的元素
	何时使用: 如果事件的函数内用到了当前元素

      2. 获取或修改标准属性: 
	elem.标准属性
        比如: elem.id
        修改样式: elem.style.css属性
      
1. 变量
   什么是: 内存中存储一个数据的存储空间
   如何使用:
     声明: var 变量名;
	特殊: 仅声明，但未赋值的变量，默认保存undefined
     赋值: 变量名=值;
	特殊: 普通模式: 给未声明的变量赋值，不会出错。会自动创建变量并保存数据。
	      严格模式: 报错！ 
     简写: 
	1. 声明同时初始化: var 变量名=值;
	2. 同时声明并初始化多个变量: 
		var 变量1=值1,变量2=值2,...  
     取值: 任何位置，只要使用变量名等效于直接使用变量的值
	特殊: 任何情况下，只要使用未声明的变量都会报错！
	    ReferenceError
2. 数据类型:
    原始类型: 值直接保存在变量本地的简单数据类型
	number: 保存用于计算或比较的数字类型
		即可存整数，也可存浮点数
	   内存占用: 整数 4字节   浮点数 8字节
	   特殊: 舍入误差，
	     解决: 按指定小数位数四舍五入n.toFixed(d)
        string: 保存用于显示或标识的一串字符
	        必须用引号包裹，但单双引号不分
	   内存占用: unicode编码
		一个汉字：占2字节
                一个字母，数字或英文标点：占1字节
           特殊: 字符串一旦创建，内容不可改变，只能整体替换
        boolean: true   false
        undefined: undefined
        null: null
    引用类型: 值无法直接保存在变量本地的复杂类型

正课:
1. ***数据类型转换
2. ***函数
3. 分支结构

准备:
  设置空白页: 三->设置->启动时->打开特定网页...->设置网页:
		输入:about:blank->回车->点确定
  控制台常用操作: 
    1. 基本操作: 输入一条语句，按回车执行
    2. 输入多行: shift+回车
    3. 清屏: 点左上角clear图标
    4. 切换已经执行过的语句: 键盘上下键
    5. 方法字体: ctrl+鼠标滚轮

1. 数据类型转换: 
   js是弱类型语言: 要求不严格
       1. 声明变量时，不需要提前指定变量的数据类型
       2. 同一个变量，先后可保存不同类型的数据
       3. 在运行时，会根据程序自身的需要，隐式转换数据的类型
   
   隐式转换: 程序自动完成的，不需要程序员干预的数据类型转换
       算数运算: + - * / %
	   %:取余数,模运算: m%n，m除以n，取除不尽余数部分
	算数运算的返回结果，一定是一个数字
       转换规则: 默认所有值都转为数字类型number，再计算
           特殊: 1. +运算中，只要碰到字符串:
                  就统一转为字符串，+运算变为字符串拼接
		 2. bool类型: true->1  false->0
                 3. 如果参与计算的数字，无法被隐式转为number
		    则被转为NaN(not a number),无效数字
                      NaN参与任何算数计算，结果永远为NaN
   课堂练习: 
       typeof(变量名) 返回变量中保存的值的数据类型名

   强制转换: 程序员主动干预，执行的数据类型转换
   何时使用: 只要默认隐式转换的结果不是想要的，就要强制转换
       转数字: 
	任意类型 转 数字: Number(x) 
	   其实，隐式转换时，调用的就是Number函数 
           问题: 只能转换纯数字组成的字符串
        字符串 转 数字: parseInt(str); 
        何时使用: 只要将字符串转数字，都用parseInt
            原理: 从头依次读取字符串中每个字符
	          跳过开头的空字符
                  仅读取数字字符
                  碰到第一个非数字字符，就停止
            问题: 不认识小数点，只能读取整数部分，省略小数
          如果转浮点数: parseFloat(str)
	    用法和parseInt完全相同！
            只不过，多认识第一个小数点
            parseFloat也可转整数，实际开发中经常用parseFloat代替parseInt。
    
    课堂练习: 输入框:
     什么是输入框: 专门收集用户输入的数据的对话框
     如何使用: var input=prompt("提示信息")
         弹出输入框，显示"提示信息"
         用户在输入框中输入数据，点确定
         输入框返回用户输入的数据给程序的变量
     强调: 凡是从页面上获得的，都是字符串！

2. ***函数:
   什么是函数: 封装一项任务的步骤清单的代码段，再起一个名字
   为什么: 代码重用！
   何时使用: 如果一项任务，可能被反复执行
   如何使用:
       声明: 将一项任务的步骤清单定义在一个函数内
	function 函数名(参数列表){
	    步骤清单
            return 返回值;
        }
        函数名，就是任务名
        参数列表: 
          什么是参数：专门保存执行任务所必须的数据 的变量
	  何时定义： 如果一项任务，必须提供指定数据才能正常执行时，就必须定义参数。
          如何定义: 在函数名后的()中，不用var声明，直接写变量名。多个变量之间用逗号分隔。不用初始化。
        返回值: 一项任务的执行结果
          何时定义: 使用者需要获得任务的执行结果时，就要定义返回值。
	  如何定义: 在函数体的结尾，使用return 值;

       调用: 让引擎按照函数的步骤执行任务
       如何调用: var 返回值=函数名(参数值列表);

1. ***函数
2. ***分支结构

1. ***函数:
   函数只有调用才执行！不调用不执行！

   ****变量的范围(scope,作用域):
   js中两种范围: 
    1. 全局: 在函数外声明的变量都属于全局――也称全局变量
             全局变量: 在程序任何位置，都可访问到！
    2. 函数内: 在函数内声明的变量或函数的参数――也成局部变量
             局部变量: 只能在函数内使用
    总结：变量使用的规则：优先使用当前范围内的变量
                          如果自己没有，就要用全局的
                          如果全局还没有，就报错！

   ****按值传递: 两变量间赋值或将变量作为参数传入函数时
                 其实都是将原变量中的值复制一个副本给对方
      结论:对于原始类型的值，函数内修改参数变量，不影响外部的全局变量。

   ****声明提前(hoist):
       在程序正式执行前
       都会将var声明的变量和function声明的函数，提前到当前范围的顶部集中创建。
       但是，赋值留在原地！

   鄙视时: 如果发现先使用，后声明的情况，都是在考声明提前
       解决: 都要先改为声明提前后的样式，再判断输出
正课:
1. 全局函数:（了解）
2. 分支结构:

1. 全局函数: ES标准中规定的，不需要任何对象就可直接访问的函数
     包含: W3C手册->JavaScript->JavaScript->JavaScript对象
           ->JS Functions
   编码解码: 
     问题1: url标准规定，在url中不允许出现多字节字符
           比如: 汉字
           wd=宋         小         宝
           wd=%E5%AE%8B  %E5%B0%8F  %E5%AE%9D utf-8编码
     解决: 编码:将url中的多字节字符，转化为单字节字符
	var url=encodeURI("url");
           解码: 将编码后的url，解码回原文
        var url=decodeURI("url");
     问题2: url标准规定，url中不允许出现保留字符: 
           比如: : /
     解决: 编码: encodeURIComponent("url")
           解码: decodeURIComponent("url")

   eval: 专门执行字符串格式的表达式:
      何时使用: 用于将收到的服务器响应字符串转化为程序中的代码
      如何使用: eval(str)
      强调: 普通模式下: eval中代码的作用域就是eval所在的作用域
            严格模式下: eval自己一个作用域
                        eval中声明的变量或函数，在eval外不能用
   
   isFinit: 专门用于判断一个数是否在有效范围内
      infinity: js中除数可以为0，结果为infinity，表示无穷大
      判断一个结构是否为无穷大: var bool=isFinite(num)
		num在有效范围内，返回true
                num是NaN或Infinity，返回false

2. 分支结构: 根据不同的条件，执行不同的操作
    隐式转换: 分支结构中的条件都默认转为bool类型
    1. 一个条件，一件事，满足才做，不满足就什么也不做
       如果操作简单: 短路逻辑: 条件&&(操作1,操作2,...)
       如果操作复杂: if(条件){操作}
    2. 一个条件，两件事，二选一执行
       如果操作简单: 三目(条件，三元)运算
          如何使用:     条件? 操作1  :   操作2
       如果根据不同的条件选择不同的值: 条件?值1:值2
	  在值1和值2中二选一。
       如果操作复杂: if(条件){操作1}else{操作2}
    3. 多个条件，多件事，多选一执行
       如果操作简单: 三目运算
          如何使用: 条件1?操作1:
                    条件2?操作2:
                        ...?...:
                        默认操作;
       如果根据不同条件返回不同的值: 
                    条件1?值1:
                    条件2?值2:
                      ...?...:
                       默认值
       如果操作复杂: if(条件1){操作1}
                 else if(条件2){操作2}
                         ...    ...
                       else{默认操作}
       如果条件都是等值比较: switch case
           如何使用: switch(表达式){
                         case 值1:
                             操作1;
                         case 值2:
                             操作2;
                         case ...:
                             ...
                         default:
                             默认操作
                     }
           先计算表达式的值
	   用表达式的值和每个case做*全等*比较
           如果表达式的值等于case的值，就进入case执行操作
         问题: 入口case及其之后的所有case都会执行
         解决: break; 中止并退出当前结构
	   如何使用: 默认，每个case之间都要用break分隔
       何时不需要加break: 1. 最后一个不用加break
                     2. 相邻两个case执行相同操作时，之间不用加

       关于默认操作: 
	   三目运算: 最后一个默认值或默认操作，不能省略
           if else: 最后一个else可省略，后果，如11:47 2016/4/2311:47 2016/4/23果所有条件都不满足，则什么也不执行.
           switch case: 最后一个default也可省略
  书: JavaScript权威指南 （犀牛书）
公众号: 前端大全
www.js1k.com

正课:
1. 运算符和表达式

1. 运算符和表达式
   1. 算数运算
   2. 关系运算: 做比较，做判断
      包括: > >= < <= == !=
      返回值: bool类型true/false
      隐式转换: 默认,都转为数字再比较
                特殊,两个值都是字符串时，按位比较每个字符的unicode号。
      特殊: 1. 区分null和undefined
             全等===: 要求数据类型首先相等，再比较值是否相等
                      不带隐式转换的==比较
             何时使用: 只要不希望在等于比较时，自动隐式转换
             固定套路: 今后，只要区分null和undefined，就用全等
             不全等!==: 不带隐式转换的!=比较，作为全等的反义
            2. 判断NaN：
             问题：不能用==或!=判断
             解决: var bool=isNaN(num)
	       何时使用: 判断num是否是NaN时专用。
                   返回值: num是NaN，就返回true
                           不是NaN，就返回false

     3. 逻辑运算: 将多个条件(关系运算)综合起来得出最终结论
          包含: &&(逻辑与，而且)    ||(逻辑或，或者)     !
           条件1&&条件2: 只有两个条件都为true时，才返回true
                         只要其中一个为false，就返回false
           条件1或条件2: 只要其中之一为true，就返回true
                         除非2个条件都为false，才返回false
           !条件: 取反      

          隐式转换：将每个条件隐式转为Boolean
       运算符优先级: 见:operators.jpg
            优先级高的先运算
    ***短路逻辑: 如果前一个条件已经可以得出最终结论
                 则后续条件不再执行。
       &&: 如果前一个条件为false,后续条件不再执行。结论为false
       ||: 如果前一个条件为true，后续条件不再执行。结论为true
    ***利用短路逻辑: 
      &&: 实现简单分支: 一个条件一件事，满足就做，不满足就不做
	条件&&操作; 相当于：if(条件){操作}
            只有条件满足(true)，才执行后续“操作”
            如果条件不满足，就什么也不做
      ||: 实现两个值，二选一。
        值1||值2: 如果值1转为bool后为true，则返回值1
                  如果值1转为bool后为false，则选值2返回 

       返回值: 默认逻辑预算返回bool值true、false    
	  在利用短路逻辑时，不再返回bool值，而是返回两个值之一

     4. 位运算: 
       左移和右移: 
         n<<m => n*  2的m次方
         n>>m => n/  2的m次方
       固定套路: 取整: n>>>0   n^0    n|0

     5. 赋值运算: 
        =: 将等号右边的值，保存在等号左边的变量中
           赋值表达式也有返回值: 返回将要保存回变量的新值

        扩展赋值运算：简写:
          a=a+5;  简写为: a+=5;  累加
          a=a-5;  简写为: a-=5;  
          a=a*5;  简写为: a*=5;
          a=a/5;  简写为: a/=5;
          a=a%5;  简写为: a%=5;

     ***递增/递减: 简写:
          a=a+1;  简写为: a+=1;   简写为: a++;
          a=a-1;  简写为: a-=1;   简写为: a--;

      前++和后++: a++ vs ++a;
          相同点: a中的值一定被+了1
          不同点: 返回值: a++返回a的旧值
                          ++a返回a的新值
	
     正课:
1. 运算符和表达式:
   
1. 运算符和表达式:
   程序: 人的想法，在计算机中的执行
   运算符: 程序中，模拟人想法的特殊符号
   表达式: 由数据，变量和运算符组成的公式
           所有的表达式，都有一个返回值

   算数运算: + - * / %
       返回值: 通常都是数字！不区分整数和浮点数
        JavaScript: 10/4  2.5     
	vs Java: 10/4  2
       隐式转换: 默认都转为number，再运算
                特殊: +运算中，碰到一个字符串，则都转为字符串
	              +运算变为字符串拼接
       %: 模运算，取余数: m%n，m除以n，取除不尽的余数部分
       何时使用: 1. 限制运算结果的最大值<除数n
                 2. 判断能否整除
	            判断偶数: num%2==0
                    判断奇数: num%2!=0
   正课:
1. 如何调试程序
2. ***变量
3. ***数据类型

1. 如何调试程序:
   bug: 程序运行过程中遇到的错误
   debug: 发现问题，并解决问题
   如何调试: 只要希望的效果没出来，先按F12，打开console
   如果程序出错，在console会提示错误的原因和位置
	回到js文件中的相同位置，修改后，重新运行

ECMAScript3.1
基本语法: 
    1. js中区分大小写
    2. 每句话结尾强烈建议用分号结束
注释:
   多行注释: /*
	       注释的内容
	     */
   单行注释: //注释的内容

2. ***变量:
   什么是变量: 内存中，存储数据的一块存储空间，再起一个名字
   何时使用: 只要一个数据，可能被反复使用，就都要先保存在变量中，再使用变量。
   如何使用: 
       声明: 在内存中开辟一块存储空间，再起一个名字 
       如何声明: var 变量名;
       强烈建议: 所有变量必须用var声明;
	特殊: 仅声明，但还未赋值，默认保存的是undefined
	什么是undefined: 所有变量的默认值
       赋值: 将数据保存到变量中
       如何赋值: 变量名=值; 
       意为: 将等号右边的值，保存到等号左边的变量中。
	特殊: 如果给未声明的变量赋值，会自动创建――强烈不建议
              预防: 在程序开始开始位置加一句: "use strict";
       简写: 声明同时就初始化变量的值:
       什么是初始化: 第一次给变量赋值
       var 变量名=值;
 
       同时声明多个变量:
       var 变量名1=值1,变量名2=值2,...;

       取值: 从变量中取出值，做运算
       如何取值: 任何位置，只要使用变量名，就等效于使用变量中的值。
	特殊: 试图从未声明的变量中取值，报错:ReferenceError:

       变量的命名: 
       建议： 1. 见名知义: 
              2. 驼峰命名: 首字母小写，之后每个单词首字母大写
       禁忌: 1. 不能以数字开头
             2. 不能使用js保留字
                什么是保留字: js已经占用的，具有特殊意义的词

    常量: 
    什么是: 一旦创建，值不可改变的量
    何时使用: 如果一个值，一旦创建，不能被修改，就要保存在常量
    如何使用: 
	创建: 常量(const) 常量名=值;
	  一般常量名 全部大写！
        使用: 除了值不能改之外，其余和普通变量用法完全一样
    
3. ***数据类型: 
   什么是数据类型: 一个数据在内存中的存储格式
   为什么: 现实中不同类型的数据，都能执行不同的操作
	   不同的操作，需要专门存储格式支持。
   2大类: 
      原始类型:值直接保存在变量中 的数据类型
	5类:
         数字类型number: 程序中专门存储数字的类型
	     number可存储整数和浮点数
         何时使用: 一个数字可能用于计算或比较时
         如何使用: 程序中凡是不加引号的数字，默认都是数字类型
	 内存占用: 整数 占4字节 32位
                   浮点数 占8字节 64位
             数值大小和存储空间无关
         特殊: 
	    舍入误差：计算机中也有计算不尽的数字
                 减，乘，除都可能发生。
            无法彻底避免
            只能近似解决: 将计算结果，按指定小数位数四舍五入
                    n.toFixed(d);//d表示小数位数  
	

         字符串类型string: 程序中专门存储一串文字的类型
         何时使用: 如果一串字符仅用于显示或标识只用，就要加""
         如何使用: 程序中凡是用引号包裹的一串文字，默认是字符串。
	     字符串一般不用做计算或比较大小。
	 内存占用: js使用unicode编码保存每个字符
           什么是unicode编码: 对全球主要语言中每个字编一个号
	     练习: 获取一个字的unicode号
	   1个汉字占 2字节 
	   1个英文字母或数字，标点占 1字节
           字符串的内存占用直接取决于字符个数
         特殊: 
	   字符串的内容，一旦创建不可改变，只能整个替换。

         布尔类型boolean: 只有两个值: true/false
	 何时使用: 今后只要表示一个判断的结果，就用布尔类型
         undefined:undefined: 是所有变量的默认值
         null:null ?
      引用类型:值不直接保存在变量中 的数据类型

回顾：
1. 分支结构:作业

正课:
1. 循环:
2. 数组

1. 循环: 程序反复执行同一代码段
   何时使用: 反复执行同一代码段
   如何使用: 
      三要素: 1. 循环条件: 允许再次*进入*循环的条件
	      2. 循环变量: 循环条件中用作比较的变量
		     从?开始，到?结束，每次递增/减?
              3. 循环体: 要反复执行的同一代码段

   如果循环变量的变化没有规律: while
     var 循环变量=初始值;
     while(循环条件){
	循环体;
        迭代变化循环变量;
     }

   do-while: 先执行一次循环体，再判断条件
     何时使用: 如果第一次条件都不满足，也希望至少执行一次时
     如何使用: 
	var 循环变量=初始值;
     	do{
	   循环体;
	   迭代变化循环变量;
     	}while(循环条件);
     鄙视: vs while： 只看第一次条件是否满足:
         如果第一次条件满足，则两者效果完全相同！
         如果第一次条件不满足，
	      do while至少可以执行一次
                 while一次都不执行

   如果循环变量的变化有规律: for
     for(var 循环变量=初始值;循环条件;迭代变化循环变量){
	                     循环体;
     }
    for的特殊用法: 
        1. 第一部分可同时声明并初始化多个循环变量,也可省略或移到循环之前外部。
        2. 第三部分可同时执行多个短小的操作，用逗号分隔，也可省略，还可以放在循环内部循环体之后
        3. 死循环: for(;;)    while(true)

    退出循环: 2种办法：
	1. 使用循环条件: 优雅，要求高――建议
        2. 使用break，随时手动退出循环: 野蛮，简单
	
    continue: 跳过本轮循环，继续下一轮

正课:
1. 数组:

1. 数组: 
   什么是: 连续存储多个数据的存储空间，再起一个名字
           多个变量的集合，起一个统一的名字
   为什么: 连续存储的数据结构，便于提高程序的执行效率
           便于分类管理多个相关数据
   何时使用: 只要连续存储多个数据就用数组
   如何使用: 
       创建: 1. 创建空数组: var arr=[];
		    强调: 只要见到[]，都是创建新数组的意思
                            var arr=new Array();
            2. 创建数组同时，初始化数组元素: 
                            var arr=[值1,值2,...]
                            var arr=new Array(值1,值2,...);
            3. 创建n个空元素的数组: var arr=new Array(n);
       访问元素: arr[i]
           i是下标: 唯一标识数组中每个元素的位置的序号
                    自动分配的下标默认从0开始，每次增1
           每个数组元素的用法和变量完全一样
           特殊: 越界: 都不会报错
	     赋值时： 在指定位置添加新元素并自动修改length属性
		下标不连续的数组叫稀疏数组
	     取值时: 返回undefined
       数组的属性: arr.length 记录数组中理论上的元素个数
	   特点: arr.length永远是最大下标+1
                 最大下标永远是arr.length-1
           固定套路: 数组最后一个元素: arr[arr.length-1]
                     在数组末尾追加新元素:arr[arr.length]=值
       遍历: for(var i=0;i<arr.length;i++){
                  arr[i]//当前元素
             }

     数组是引用类型的对象: 
     垃圾回收: 释放不再被引用的对象
     垃圾回收器: 在后台自动执行的，回收不再使用的对象的程序。
        一个对象每被一个变量引用，引用计数器都会+1 
	何时回收: 只有一个对象，不再被任何变量引用（引用计数器为0）时，垃圾回收器就会自动释放对象的空间。
     问题: 无法实时回收
     建议: 使用完较大的对象后，主动释放总是好的习惯
          如何释放: 变量名=null

     索引数组: 下标为序号的数组
	关联数组前所学的数组都是索引数组

     关联(hash)数组: 
 	什么是: 可自定义下标名称的数组
        为什么: 有些数组的元素必须指明其表示的意义
	        查找极快，查找速度和元素个数无关，因为无需遍历
        何时使用: 希望按照元素名称快速定位(查找)数组元素时
        如何使用: 
            创建: 2步:
                var arr=[];
                arr["sname"]="杨幂";
                arr["shx"]=81;
                arr["yuw"]=53;
                arr["yy"]=89;
            访问元素: 和索引数组完全一样
		arr["下标"]
    ***原理: 
	  hash算法: 专门接受一个字符串，并计算出一个尽量不重复的编号。相同字符串，计算出的号一定相同！不同字符串，计算的号几乎不相同。
          添加元素时: 将下标名称交给hash算法，计算出一个唯一的序号，将值保存到数组对应序号的元素中。 
          读取元素时: 将下标名称交给hash算法，计算出一个和存入时完全相同的序号，直接查找序号位置的元素值。不需要遍历！ 
        
        特殊: 关联数组length属性失效(永远为0)
        遍历: 依次获得arr中每个下标的名称,保存在变量key中
	      for(var key in arr){
		arr[key]//当前元素
              }  

    常用API: 
    1. 转为字符串: 
      1. String(arr): 输出数组的每个元素值，用逗号分隔
      2. arr.join("分隔符"): 输出数组的每个元素值，用指定"分隔符"分隔。
	如果join中省略分隔符，则join等效于String
      比如: 单词拼成句子: words.join(" ")
            字符拼成单词: words.join("");
      固定套路: 频繁的字符串拼接会浪费内存
            解决：将字符串换为数组，将拼接换为在数组末尾追加新元素。在拼接完数组后，使用join("")将数组拼接成想要的字符串

    2. 连接和截取: 
       1. 连接: 将两个数组拼接为一个新数组
                或者将多个元素，追加到数组结尾，生成新数组
          var newArr=arr1.concat(arr2);
           concat不修改原数组，总是返回新数组
          var newArr=arr1.concat(值1,值2,arr2,值3,...)
	   强调: concat会自动打散参数中的数组，以单个元素形式拼接到新数组中。
       2. 截取: 选取开始位置到结束位置之间的子数组
            var subArr=arr.slice(starti,endi+1);含头不含尾
            意为: 截取arr中starti位置开始到endi位置之间的子元素组成的子数组。
	    注意: 含头不含尾
	    slice不修改原数组，总是返回新数组
	    第二个参数可以省略，表示截取到结尾；
	    如果想要截取到结尾，就可以省略第二个参数
		支持负数参数（倒数下标）；arr.slice(-4);

     3. splice: 删除，插入，替换
        删除: var deleted=arr.splice(starti,n);
              删除arr中starti位置开始的n个元素
              直接删除arr中的元素
              返回被删除的元素组成的临时数组
              如果被删除的元素不想要了，可省略赋值部分
        插入: arr.splice(starti,0,值1,arr2,....)
	      在arr中starti位置插入值1或arr2中的元素
              原starti位置及其之后的元素被向后顺移
              强调：splice不会自动打散参数中的数组
        替换: var deleted=arr.splice(starti,n,值1,arr2,....)
	      在arr中先删除starti位置开始的n个元素，再在starti位置插入新元素。
    4. 颠倒数组: arr.reverse();
回顾:
1. ***数组API
   1. 转字符串: 
      String(arr): 输出元素的内容，用逗号分隔每个元素
      arr.join("分隔符"): 输19:56 2016/4/2619:56 2016/4/2619:56 2016/4/2619:56 2016/4/26的20:38 2016/4/8内容，可自定义分隔符
   2. 拼接和截取: 都不修改原数组，只能返回新数组
      1. 拼接: var newArr=arr1.concat(值1,值2,arr2,值3,...);
      2. 截取: var subArr=arr.slice(starti,endi+1);
	说明: 1. 如果希望截取到结尾，就可省略第二个参数
              2. slice支持负数参数(倒数下标)
   3. splice: 
      1. 删除: var deleted=arr.splice(starti,n);
      2. 插入: arr.splice(starti,0,值1,值2,...)
	   强调:splice不会自动打散参数中的数组
      3. 替换: var deleted=arr.splice(starti,n,值1,值2,...)
   4. 颠倒: arr.reverse();

正课: 
1. ***数组:
   排序
   栈和队列
   二维数组
2. ***String

1. ***数组:
   排序: 
     自定义排序算法: 冒泡排序（手写）
     排序API: arr.sort(); 
            意为: 将arr中元素按升序排列
            强调: 默认将每个元素都转为字符串，PK unicode号
            何时使用默认排序: 只有排序字符串类型的元素时
       如果排序除字符串外的其他类型就要自定义比较逻辑！
     自定义比较逻辑: 
       2步: 1. 定义比较器函数：
              什么是: 专门比较任意两值大小的函数
                要求: 一定有2个参数: a,b
                      返回值: 如果a>b，就返回正数
                              如果a<b，就返回负数
                              如果a==b，就返回0
              如何使用: function compare(a,b){
 		            return a-b;
                        }
            2. 将比较器函数作为参数传入sort函数中
               arr.sort(比较器函数名)
   降序排列: 颠倒比较器函数返回值的正负，可改升序为降序
       function compare(a,b){return -(a-b);}

正课:
1. ***数组
   栈和队列
   二维数组
2. ***String

1. ***数组:
   栈(stack)和队列(queue): 
	其实都是普通数组，只不过调用了不同API而已
   栈: 一端封闭，只能从另一端进出的数组
    FILO
    何时使用: 希望始终使用最新进入数组的元素时
    如何使用: 
       1. 从结尾出入栈
	  入栈(压栈): arr.push(值1,值2,...)
	     不支持数组参数
          出栈(弹栈): var last=arr.pop();
          好处: 无论出入栈都不改变剩余元素的位置
       2. 从开头出入栈
	  入栈: arr.unshift(值1,值2,...)
	     unshift入栈的顺序值从右向左读取参数
          出栈: var first=arr.shift();
          缺点: 每次出入栈都会导致其余元素的位置改变

    队列: 从结尾进入，从开头出的数组
      FIFO
      何时使用: 希望按照先来后到的顺序依次使用元素时
       1. 入队列(排队): arr.push();
       2. 出队列: var first=arr.shift();

    二维数组: 数组中的元素，又引用另一个子数组
      何时使用: 1. 要存储的数据就是横行竖列的二维数据时
                2. 如果多个数据需要分类存储时
      如何使用: 
         创建: 2步: 
           1. 创建空数组
	      var data=[];
           2. 向数组中添加新元素，新元素再赋值为一个子数组
              data[0]=[8,4,4,2]
              data[1]=[4,16,8,4]
           也可在创建同时初始化子数组: 
              data=[
                  [8,4,4,2],
                  [4,16,8,4]
              ]
      访问数组中的元素: 
          arr[r] --> 获得下标为r位置的子数组
          arr[r][c] --> 获得r行c列位置的元素
                        单个元素的用法和普通变量完全一样
        强调: 越界: r不越界，c越界，返回undefined
                    r越界，报错
      遍历: for(var r=0;r<arr.length;r++){
		for(var c=0;c<arr[r].length;c++){
		    arr[r][c]//当前元素
 		}
            }

2. ***String: 
   内置对象: ES标准中规定的，浏览器厂商已经实现的API
   11个: String Number Boolean ->包装类型
         Array Date Math RegExp
         Error
         Function Object
         Global（window）
   包装类型: 专门封装原始类型的值，并提供操作值得API 的对象
   为什么: 原始类型的值不能拥有属性和方法
           但是实际开发中需要对原始类型值反复执行相同操作
   如何使用: 自动创建和调用
     生命周期: 
	创建: 试图用原始类型的值调用函数时，自动创建对应类型的包装类型对象。
          其实调用的是包装类型对象的函数。
        释放: 调用完函数后，自动释放！
          
   什么字符串: 一串字符组成的只读数组
       相同: 1. 用[i]方式访问每个字符
             2. 都有length属性记录字符个数
             3. 都可用slice截取子字符串
             4. 都用for遍历每个字符
   String API: 所有API都不直接修改原字符串，只能返回新字符串
   1. 转义字符: 将字符串内容中和语法冲突的特殊符号转为普通字符
         比如: \" \' \\
                在字符串中代替空字符: \n 换行  \t制表符
   2. 大小写转换: 
      何时使用: 不区分大小写时，都要先转为统一的大小写，再比较
      如何转换: 
          str=str.toUpperCase();
          str=str.toLowerCase();
   3. 获取指定位置的字符: 
          var char=str.charAt(i); =>str[i]
          var unicode=str.charCodeAt(i);
              获得str中i位置字符的unicode号

正课: 
1. ***String
   *****正则表达式
   ***检索关键词
   ***替换(删除，格式化)
   切割

1. ***String
   *****正则表达式: 
     6. 指定匹配位置: 
        ^字符串开头
        $字符串结尾
        同时前加^后加$，表示从头到尾必须完整匹配()
        何时使用: 在查找和替换中，很少使用
                  在验证中，要求从头到尾必须完整匹配，用^和$
        \b: 单词边界: 字符串开头，空字符，标点，字符串结尾
          何时使用: 专门匹配符合条件的单词
        比如: no zuo no die nothing 中
            \bno 返回3个 ――以no开头的单词
            no\b 以no结尾的单词  返回2个
            \bno\b 独立的no 返回2个
        鄙视题: 匹配首字母和结尾字母相同的单词
            首字母:\b([a-zA-Z])
            中间字母: [a-zA-Z]+
            结尾字母: \1\b
            \b([a-zA-Z])[a-zA-Z]+\1\b
          强调: 正则表达式中每个分组，自动会获得一个序号
                序号从1开始
                后边希望匹配和前边分组相同的内容可用\n匹配

        密码强度: 
	8位字母数字的组合，至少包含一位大写字母和一位数字
        预判: 从头到尾预览字符串
        1. 不全由字母组成: (?![a-zA-Z]+$)
           结论: 至少包含一位数字，还可能有特殊符号
        2. 不全由小写字母和数字组成: (?![0-9a-z]+$)
           结论: 至少包含一位大写字母，还可能包含特殊符号
        3. 只能由字母和数字组成: [0-9A-Za-z]{8}
		排除特殊符号的可能
	(?![a-zA-Z]+$)(?![0-9a-z]+$)[0-9A-Za-z]{8}

    ***检索关键字: 
      1. 查找固定关键词: var i=str.indexOf("关键词",fromi);
                    var i=str.lastIndexOf("关键词",fromi);
      2. 使用正则表达式查找： 3种
	在js中创建正则: 
            var reg=/正则表达式/后缀;
               后缀: i 忽略大小写
                     g 全部
           1. 只判断有没有: var i=str.search(reg);
              在str中找第一个和reg匹配的关键词位置
		找到返回关键词位置i
                每找到返回-1
           2. 检索所有关键词的内容，不返回位置: 
              Step1. 创建正则时，加后缀g
              Step2. var kwords=str.match(reg);
                返回值: 返回包含所有关键词内容的数组
                    ***没找到，返回null
 			一定要先判断不是null，再后续操作
                特殊: 万一正则没加g
                  match：返回一个数组: 
            [第一个敏感词,第一组子字符串,第二组子字符串,...]
	          .index属性保存了第一个敏感词的位置
           3. reg.exec();

     ***替换: (删除,格式化)
        str=str.replace(reg,"替换后的新值");
           如果替换的值和关键词无关，是固定的，用上一种方法
           如果替换值依赖于本次找到的关键词，用下一种方法
        Step1: 定义一个函数：
	   var fun=function(kword[,$1,$2,...]){
		根据本次找到的关键词kword，返回新的替换值
	   }
	Step2: 将函数对象传入replace，作为第二个参数
	   str=str.replace(reg,fun);
       
        删除: 其实就是替换成空字符串
        格式化: 2步: 
          1. 用正则将要格式化的内容分组
          2. 用替换将分组重新拼接为新的格式
	      获得第n个分组的子字符串? 在替换值内用$n
    切割: 按指定分隔符，将字符串分割为多段子字符串
	var substrs=str.split(reg);
	返回值: 子字符串组成的数组，
		分隔符不包含在结果中

    
回顾:

正课:
1. ***String
   截取子字符串
   ***查找关键字
      *****正则表达式
   ***替换(删除，格式化)
   切割

1. ***String
   截取子字符串: 3种:
     var substr=str.slice(starti[,endi+1]);
                str.substring(starti[,endi+1]);
                不支持负数参数，可用str.length-n代替                           str.substr(starti,n)
                从starti开始，截取n个字符，不考虑含头不含尾
   ***检索关键词: 4种
      1. 查询固定的一个关键词: 
         var i=str.indexOf("关键词"[,fromi]);
          查找str中fromi位置之后的下*一个*“关键词”的位置
          返回值: 关键词第一个的位置下标
                  如果找不到，返回-1
          省略第二个参数，默认从0位置开始查找
         var i=str.lastIndexOf("关键词"[,fromi]);
          查找str中fromi位置之前的前*一个*“关键词”的位置
          返回值: 关键词第一个的位置下标
                  如果找不到，返回-1
          省略第二个参数，默认从length-1位置开始查找
      2. 利用正则表达式查找关键词: 
  *****正则表达式: 
       什么是: 专门描述字符串中每位字符出现规律的表达式
               格式的定义
       何时使用: 只要按规律同时查找，替换，验证多个关键词时
	         都要先定义格式规则
       如何使用:
           1. 最简单的正则就是关键词的原文
	   2. 字符集: 规定一位字符的备选字符列表
              [备选字符的列表]
              强调: 一个字符集[]，只能匹配一位字符
              特殊: 1. 如果字符集中的字符部分连续
                       可用-省略中间的字符，-读作“到”
                常用: 一位数字: [0-9]
                      一位大写字母:[A-Z] 小写[a-z]
                      一位汉字: [\u4e00-\u9fa5]
                      一位字母数字或下划线: [0-9A-Za-z_]
                    2. 除了xxx：[^xxx]
                      ^读作"除了"，必须在[]的开头
                      比如: 除了4和7之外所有字符:[^47]
           3. 预定义字符集: 对常用字符集的简化写法
              一位数字: \d  =>[0-9]
              一位字母数字或下划线: \w  =>[0-9A-Za-z_]
              一位空字符: \s  => 包括: 空格 制表符 换行

              一位任意字符: .
           何时使用: 如果需求和预定义字符集完全匹配，则优先使用预定义字符集。否则自定义普通字符集
           4. 量词: 规定字符集出现次数的规则
              一般紧跟在字符集之后，修饰相邻的字符集
              有明确数量: 
                {n,m}  最少n次，最多m次
                {n,}   最少n次，多了不限
                {n}    必须n次，不能多也不能少
              不确定数量: 
                ?  可有可无，最多一次
                *  可有可无，多了不限
                +  至少一次，多了不限
           5. 选择和分组:
             选择：或 | 表示在两个规则之间挑一个匹配
                 优先级最低
             分组: 在正则表达式内部用()划分子表达式
               何时: 获取关键词的部分内容时，都要先分组再匹配
                     希望数量词修改一组字符集时
       手机号: +86或0086   可有可无，最多一次
               空字符      可有可无，多了不限
               1
               3,4,5,7,8
               9位数字
         (\+86|0086)?\s*1[34578]\d{9}

回顾: 
1. ***String
   1. 大小写转换: str.toUpperCase();
                  str.toLowerCase();
   2. 获取指定位置字符: str.charAt(i);
                  var unicode=str.charCodeAt(i) 
                  var char=String.fromCharCode(unicode)
   3. 获取子字符串:
        str.slice(starti,endi+1);
        str.substring(starti,endi+1);
        str.substr(starti,n);
   4. 检索关键词: 
        1. 检索一个固定的关键词:
             var i=str.indexOf("关键词",fromi);
                   str.lastIndexOf("关键词",fromi);
        2. 检查有没有: var i=str.search(reg);
        3. 获得所有关键词的内容: 
	    var arr=str.match(reg);//reg一定要加g
        4. 即找每个关键词的内容，又找位置:
            var arr=reg.exec(str)
   5. 替换: 删除和格式化
       str.replace(reg,"替换值");
       str.replace(reg,function(kword,$1,$2,....){
	    return 处理后的替换值;
	});
      删除: 将关键词替换为""
      格式化: 2步: 
          Step1. 用正则将关键词分组
          Step2. 在replace的第二个参数中用$n，重新拼接新的格式
              $n 正则中第n个()匹配的子关键词
    6. 切割: var subs=str.split(reg);
         固定套路:将字符串打散为字符数组: 
		var chars=str.split("");

2. *****正则表达式:
   1. 最简单的正则表达式: 关键词原文
   2. 字符集: [备选字符列表]
	如果字符列表部分连续: 可用-省略中间字符
        如果表示除了个别字符: [^xxx]
   3. 备选字符集:
        一位数字 \d  一位字母数组或下划线: \w
        一位空字符 \s  任意一个字符: .
   4. 量词:
        有明确数量: 
          字符集{m,n}  至少m次，最多n次
          字符集{m,} 至少m次，多了不限
          字符集{m}  必须m次，不能多不能少
        没有明确数量: 
          字符集?  可有可无，最多一次
          字符集*  可有可无，多了不限
          字符集+  至少一次，多了不限
   5. 选择和分组: 
      选择: 或 |
      分组: () 每个分组在匹配时，自动获得一个序号，从1开始
           2种用途: 1. 在正则内部\n，匹配和第n个分组相同的内容
                    2. js中使用$n获得关键词的第n个分组子关键词
   6. 指定匹配位置: 
      ^: 字符串的开始位置
      $: 字符串的结束位置
      \b: 单词边界, 默认仅匹配一边。
	如果匹配独立单词，要两边同时加\b
      
   密码强度: 8位字母数字的组合，至少包含一位大写字母和一位数字
       1. 不都是字母: 至少有一个数字或特殊符号
         (?![a-zA-Z]+$)
       2. 不都是小写子母和数字: 至少有一个大写字母或特殊符号
         (?![a-z0-9]+$)
       3. 只能由字母和数字组成:
         [a-zA-Z0-9]{8}
       结果： ^(?![a-zA-Z]+$)(?![a-z0-9]+$)[a-zA-Z0-9]{8}$

正课:
1. ***RegExp:
2. Math:
3. *Date:

1. ***RegExp: 专门封装一个正则表达式，提供用正则表达式执行查找和验证的API  的对象
    1. 创建: 
	1. 直接量: var reg=/正则/ig;
	   何时使用: 如果正则是固定的，不需要动态拼接
           转义: 如果包含/,都要转为\/
        2. 使用new关键字: var reg=new RegExp("正则"[,"ig"]);
           何时使用: 如果正则不是现成的，需要运行时拼接
           转义: 如果包含"或'，都要转为\"和\'
                 如果包含\d,\w,\s，必须写成\\d,\\w,\\s
    2. API:
      1. 查找关键词：查找每个关键词的内容和位置
        var arr=reg.exec(str);
          意为: 在str中查找下*一个*和reg匹配的关键词
          返回值: arr: [kword,$1,$2,...]
                          0
                  arr.index: 保存了本次找到的关键词的位置
              如果没找到返回null
          原理: 默认从开头查找下一个关键词
              如果找到，就将将关键词保存在结果数组的第一个元素
              将关键词位置保存在结果数组的index属性中
            exec自动将reg的lastIndex调整到本次找到的关键词之后
                reg.lastIndex： 标识正则下次匹配的开始位置
       课堂练习: 
         贪婪模式: 正则表达式默认匹配最长的符合条件的字符串
	     比如: .* .+
         懒惰模式: 让正则仅匹配最短的符合条件的字符串
             贪婪->懒惰: (.*?) (.+?)
         
正课:
1. ***RegExp:
2. Math
3. *Date
   
1. ***RegExp: 
   1. 查找关键词：查找每个关键词的内容和位置
      var arr=reg.exec(str);
      返回值: arr:[kword,$1,$2,...]
              arr.index: 本次找到的关键词的位置
              RegExp.$n: 直接获取第n个分组的子内容
      强调: reg要加g，才能反复查找所有。
            不加g，仅查找第一个关键词
   2. 验证: var bool=reg.test(str);
        验证要求完整匹配，通常前加^，后加$，不加g
        意为: 验证str是否和reg的规则完整匹配
      身份证: \d{15}(\d\d[0-9Xx])?

2. Math: 专门提供数学计算的常用API的对象
      不能new！
   1. 取整: 
       Math.ceil(num): 上取整: 只要超过，就取下一个整数
       Math.floor(num): 下取整: 只要超过，就省略小数部分
            位运算也可实现下取整: m^0  m|0  m>>>0
       Math.round(num): 四舍五入取整: 
         vs toFixed(d): d只能在0~20之间，只能返回字符串
   2. 乘方和开平方:
       Math.pow(底数,幂): Math.pow(10,2)=100
       Math.sqrt(num): 将num开平方
   3. 最大值和最小值: 
       Math.max(值1,值2,...): 在给定的多个值中返回最大的一个值
       Math.min(值1,值2,...)
       问题: 默认不支持查找数组中的最大值
       解决: Math.max.apply(Math,arr)：返回arr数组中最大元素
   4. 随机数: 
       Math.random(): 0<=r<1
       公式: 任意最大值max最小值min之间取随机整数
         parseInt(Math.random()*(max-min+1)+min);
	  min60  max  100
	parseInt(60)<=Math.random()*41<=parseInt(100)
       简化: 在0~任意值之间取随机整数
         parseInt(Math.random()*(max+1))

3. *Date: 专门封装一个时间点，提供操作时间的API
   何时使用: 只要在程序中保存日期或时间，都要用Date对象
   创建: 4种: 
    1. 创建日期对象同时获得客户端系统时间: var now=new Date();
    2. 创建自定义时间的日期对象:
　　　  var date=new Date("yyyy/MM/dd hh:mm:ss");
        var date=new Date(yyyy,MM-1,dd,hh,mm,ss);
    3. 复制一个日期: 
        假设: var d1=new Date("yyyy/MM/dd hh:mm:ss);
              var d2=new Date(d1);
   日期的原理: 
       日期对象中，封装的起始是一个1970年1月1日0点至今的毫秒数
  
   日期API: 
     日期的分量/单位: 
     FullYear Month Date Day
     Hours Minutes Seconds Milliseconds
    1. 每个分量都有一对儿getXXX()、setXXX()方法
       date.getxxx()方法，获取一个分量的值
       date.setxxx(n)方法，设置一个分量的值
       特殊: Day，没有set方法()
    2. 取值范围: 
       月中的日: 1~31 不用修正
       星期: 0~6 不用修正
       月: 0~11 ***要修正: 计算机中的月份至比现实小1
       时: 0~23 不用
       分秒: 0~59 不用

   日期计算: 
     1. 两日期可相减，结果为毫秒差
     2. 对日期的分量做加减: 3步:
       1. 取出来: var n=date.getXXX();
       2. 做加减: 
       3. 放回去: date.setXXX(修改后的n)
          setXXX方法可根据传入的数值，自动调整进制
          强调: setXXX方法直接修改原日期对象
      其实可简化为: date.setXXX(date.getXXX()+/-n)

   日期转字符串: 
     date.toString();->中国标注时间格式
     date.toGMTString();->转为国际标准时间
     date.toLocaleString();->转为操作系统当地时间格式
    *date.toLocaleDateString();
	->转为操作系统当地时间格式,仅包含日期部分
     date.toLocaleTimeString();
	->转为操作系统当地时间格式,仅包含时间部分

回顾: 
1. *Date

正课:
1. 错误处理
2. ***Function
   ***重载
   ***匿名函数
   ***作用域和作用域链
   *****闭包

1. 错误处理: 
   错误: 程序运行中发生的异常问题
         一旦发生错误，引擎停止执行后续程序
   错误(异常)处理: 在程序发生错误时，依然保证程序不强行退出的机制。
   如何处理: 
    try{
       可能出错的正常代码;
    }catch(err){
       错误处理的代码;
    }finally{
       无论是否出错，始终执行的代码
    }

   err: 在错误发生时，获得错误对象
      错误对象: 封装错误信息的对象，在发生错误时自动创建

   性能: 放在try中的代码，执行效率会降低
     建议: 1. 在try中尽量少的，仅包含可能出错的代码
           2. 绝大多数的错误，都可通过if提前预防――经验

   特殊用途：判断浏览器兼容性问题: 
   
   异常处理中的return:
    1. 如果finally中没有return：
       finally中的代码一定会在返回前被执行
          finally中的代码不会影响返回值的结果
    2. 如果finally中有return
         finally中的return会覆盖之前的return

   主动抛出异常：
     throw new Error("错误信息");
    何时使用: 函数的定义者，向函数调用者提示错误之用

2. ***Function: 封装一个函数定义，提供对函数操作的API 的对象
   创建: 3种: 
     1. 声明: function 函数名(参数列表){函数体; return 返回值}
     *********只有声明方式创建的函数才能被声明提前*********
     2. 直接量: 
	var 函数名=function(参数列表){函数体; return 返回值}
     3. 用new关键字:
        var 函数名=new Function("参数1","参数2",...,"函数体")
   
   重载(overload): 
     什么是: 相同函数名，不同参数列表的多个函数。在调用时根据传入参数的不同，自动挑选对应的函数执行。
     为什么: 现实中，不同操作步骤的相关任务，通常都起相同的任务名。为了减轻使用者的负担。
     何时使用: 多个相似的任务，具有相同的任务名，只是参数和步骤不一样，则都要定义相同的函数名。
     问题: js中不支持重载的语法。因为js不允许多个同名函数存在
     解决: arguments
       什么是: arguments是专门接受调用时所有传入的参数值的类数组对象。
	什么是类数组对象: 像数组的对象
	    vs 数组: 相同:用下标访问每个元素
                          length属性记录元素个数
                 不同: 不能使用数组的任何API
      arguments在调用函数时，在函数内部自动创建，并保存参数值

正课:
1. ***Function 
  ***匿名函数
  ***作用域和作用域链
  *****闭包

1. ***Function
   ***匿名函数: 定义时，没有给定函数名的函数
   为什么: 为了一次性使用，节省内存空间
   何时使用: 只要一个函数，只执行一次，都要用匿名函数
   如何使用: 
      1. 回调: 将函数作为对象交给别的函数去调用
           函数的调用时机，次数，以及参数与函数定义者无关
      2. 自调: 定义完函数，立刻调用
         (function(...){...})();
   作用域和作用域链: 
     作用域: 变量的可用范围
       1. 全局作用域: 全局变量，随处可用，可反复使用
       2. 函数作用域: 局部变量，仅函数内可用，函数调用后释放
     作用域链: 从当前函数的AO到全局对象window形成的链式结构

   *****闭包: 保护并重用局部变量的机制
    为什么: 全局变量: 优: 随处可用，可重用，缺: 易被污染
            局部变量: 优: 仅在函数内用，安全，缺: 不可重用
    何时使用: 希望重用一个变量，又不希望被污染时-保护局部变量
    如何定义: 3步: 
      1. 定义受保护的局部变量
      2. 定义内层函数专门操作受保护的变量
      3. 定义外层函数将受保护的变量和操作变量的函数封装起来，外层函数将内层函数返回到外部
    
    鄙视时: 
    判断闭包: 1. 局部变量  2. 内层函数  3. 外层函数
    判断输出: 
       1. 找到受保护的局部变量，判断外层函数调用后，它的值
       2. 同一次外层函数调用返回的多个内层对象，操作的是同一个受保护的变量。      
正课:
1. *****面向对象: OOP
   什么是对象: 内存中集中存储多个数据或函数的存储空间，再起一个名字。
         对象是程序中描述现实中一个具体事物的属性和功能的结构
   什么是面向对象: 程序中都是先用对象描述现实中一个具体事物，然后再访问对象的属性和功能。
   为什么面向对象: 现实中，一个属性或一个功能都必须依附在一个具体的事物上才有意义！不同的事物，即使是同一功能，它的定义也可能不一样。
   
   如何使用面向对象: 
       1. 先创建对象: ――封装
          描述现实中一个事物，需要两类成员: 
             1.事物的属性，会成为程序中对象的属性
                 属性: 对象中存储一个数据的变量
             2.事物的功能，会成为程序中对象的方法
                 方法: 保存在对象中的一个函数
             属性和方法统称为: 对象的成员
          将一个事物的属性和方法集中定义在一个对象中。
          3种:
          1. 直接量,创建*一个*独特的对象:
            var obj={
	        属性名:属性值,
                ...:...,
                方法名:function(...){...},
                ...:...
            }
    *****js中一切都是对象！对象的底层都是关联数组！
       	    1. 每个成员名其实都是字符串，但对象中成员名的引号可省略
       	    2. 都可用for in遍历对象的每个成员
            3. 对象也可在任何时候添加新成员
         对象自己的方法，如何使用自己的属性: 
    *****this: 在函数调用时，引用正在调用函数的对象 的变量
               其实就是.前的对象
            不使用任何对象调用的函数，this默认是window

          2.用new关键字: var obj=new Object();//创建一个空对象
                         obj.属性名=值;
                         obj.方法名=function(){...}

     *****3.使用构造函数，反复创建*多个*相同结构的对象: 
            构造函数: 专门描述一类对象的结构的函数 
            为什么: 代码重用！
            如何使用: 2步:
             1. 定义构造函数/类型: 
	       function 类型名/构造函数名(属性参数,...){
                   为当前对象添加指定属性，赋值为属性参数的值:
                   比如: this.属性名=属性参数
                         this.方法名=functon(...){...}
               }
             2. 调用构造函数创建对象，也称为创建类型的一个实例
                ――也称为实例化！
               var obj=new 构造函数名/类型名(属性值列表,...);
               new执行了4个操作：
                1. 创建一个空对象
                2. ?
                3. 用新对象调用构造函数
                4. 返回新对象的地址给变量

       2. 访问对象成员: 
         1. 访问属性: 对象.属性名 -> 和变量完全一样
         2. 调用方法: 对象.方法名() -> 和函数完全一样
正课: 
1. *****面向对象:
   *****原型和原型链
   *****继承

1. *****面向对象: 
   面向对象三大特点: 
      封装：将事物的属性和功能集中定义在一个对象中
      继承：父对象的成员，子对象不用反复创建，也可直接使用
      多态：同一类事物或父子关系的事物，也可能表现出不同的状态

   js中都是继承原型:
   原型对象: 集中保存一类对象共有成员的父级对象
   何时使用原型对象: 凡是所有子对象共有的属性*值*和方法，都要在原型中集中定义一次。子对象共同使用。
   如何使用: 
      如何获得原型对象: 每个函数都有一个prototype属性引用自己的原型对象。
   回顾: new 4件事: 
        1. 创建空对象
        2. 设置空对象的__proto__属性继承构造函数的原型对象
            原型对象中的属性，新对象可直接使用，不用重复定义
        3. 调用构造函数为新对象添加属性和方法
        4. 返回新对象地址保存在变量中
      如何向原型对象中添加共有属性和方法: 
        构造函数.prototype.属性名/方法名=....

   原型链: 由各级对象的__proto__属性连续继承形成的链式结构
       用来控制属性的使用顺序: 自己有，就不用父级的。
                               自己没有，才到父级找。
                             如果父级没有，继续延原型链向上找
                        如果到顶级对象都没有，才返回undefined
       vs 作用域链: 用于控制变量的使用顺序。

   自有属性和共有属性: 
     1. 判断自有属性: var bool=obj.hasOwnProperty("属性名");
        如果指定"属性"，直接保存在obj本地，则是自有属性，返回true。
        如果指定"属性"，没有保存在obj本地，则返回false。
     2. 判断共有属性: 不是自有，且在原型链中有
          !obj.hasOwnProperty("属性名")
          &&("属性名" in obj)//判断obj的原型链上是否包含指定属性。

   内置对象的原型对象: 保存了内置对象共有的API和属性值

   原型相关API: 
     1. 获得对象的父级原型对象: 2种:
       1. 通过构造函数获得: 构造函数.prototype
       2. 通过子对象获得: 
	obj.__proto__ 问题: __proto__是内部属性，可能被禁用
        Object.getPrototypeOf(obj)
     2. 判断两对象间的父子关系:
       父对象.isPrototypeOf(子对象)
         如果父对象确实是子对象的父级，就返回true
         如果父对象不是子对象的父级，就返回false
       强调: 检查整个原型链

   重写（override）: 如果子对象觉得父对象的成员你不好用，可在本地定义同名成员覆盖父对象成员
回顾:
1. *****面向对象:
   面向对象三大特点: 封装，继承，多态
   什么是封装: 将一个事物的属性和功能集中定义在一个对象中
   何时封装: 面向对象程序中，都是先将对象的属性和功能封装在一个对象中，再按需访问对象的成员
   为什么封装: 代码重用；更符合人的思维方式
   如何封装: 3种: 
     1. 仅创建一个对象: 
          1. 直接量: var obj={
                        属性名:"属性值",
                        ...:...,
                        方法名:function(){...this.属性名...}
                     };
       *****js中一切都是对象；一切对象都是关联数组: 
        	1. 每个属性都有两种访问方式: 
                      obj.属性名 或 obj["属性名"]
                2. 都可用for in 遍历对象的每个成员
                      in是获得一个对象中每个属性名
                3. 对象也可以随时添加新的属性
       *****this: 正在调用函数的对象
            何时使用: 在函数内，希望获得正在调用函数的对象时
                                        (.前的对象)
          2. 实例化Object类型对象: var obj=new Object();
                                   obj.属性=值;
                                   obj.方法=function(){}
                强调: new可省略
                      ()也可省略
                      不能同时省略
     2. 使用构造函数反复创建多个相同结构的对象：
        构造函数：专门描述一类对象的统一结构的函数
        如何使用: 2步:
           1. 定义构造函数: 
              function 构造函数名/类型名(属性参数){
                  this.属性名=属性参数;
                  ...
                  this.方法名=function(){}//浪费内存空间
              }
           2. 实例化类型的对象: 
	       var obj=new 构造函数名/类型名(属性值列表);
              new的执行过程: 
                1. 创建一个空对象
                2. 让空对象继承构造函数的原型
                   (设置空对象的__proto__为构造函数的原型)
                3. 调用构造函数向空对象中添加属性和方法
                4. 返回新对象的地址给变量

    什么是继承: 父对象的成员，子对象不必重复定义，可直接使用
    为什么继承: 代码重用; 节约内存
    何时继承: 1. 自动: 在创建对象时，默认都会继承构造函数的原型对象
              2. 手动: 希望直接获得其它对象中的成员时
    如何继承: js中一切继承都是继承原型――原型继承
    什么是原型: 保存同一类型的所有子对象共有成员的对象     
    何时将成员放入原型: 如果一个成员希望被多个子对象共有时
                       就一定要将共有成员放入原型
    如何将成员放入原型: 2步：
      1. 获得对象的父级原型对象: 2个途径:
         1. 通过构造函数获得: 构造函数.prototype
         2. 通过子对象，向上获得: 
              subObj.__proto__ //内部属性，可能被禁用
              代替: Object.getPrototypeOf(subObj)
                    获得subObj对象的父级原型对象
      2. 向原型对象中添加共有成员: 
           构造函数.prototype.新成员

    原型链: 由各级对象的__proto__属性，逐级继承形成的链式结构
    原型链中属性的使用规则: 优先使用当前对象的自有成员
                        如果自己没有，延原型链去父级对象中找
                        所有原型链的顶部都是Object.prototype
               如果找到Object.prototype都没有，就返回undefined
    vs 作用域链: 作用域链用来规定局部变量的使用顺序
       原型链: 用来规定对象的属性的使用顺序
	
    自有属性和共有属性: 
      1. 自有属性: 直接保存在对象本地的属性
        判断: obj.hasOwnProperty("属性名");
      2. 共有属性: 保存在当前对象的原型链上的属性
        判断: !obj.hasOwnProperty("属性名")
              &&("属性名" in obj)
              //in: 在obj的整个原型链上查找“属性名”是否存在

    判断继承关系: 父对象.isPrototypeOf(子对象)
        如果指定父对象在子对象的*原型链*上，就返回true
        如果指定父对象不再子对象的原型链上就返回false

*****判断一个对象是不是数组:
    typeof不能区分数组类型和对象
    1. 判断父级对象: isPrototypeOf： 检查整个原型链
       Array.prototype.isPrototypeOf(obj)
        返回true: obj本身就是数组类型
                  obj本身不是数组类型，但可能继承自数组类型
        返回false: obj既不是数组，也没有继承数组
    2. 判断构造函数: 检查整个原型链
       obj.constructor==Array 是数组，也可能继承自数组
       obj instanceof Array 是数组，也可能继承自数组
    3. 判断对象的内部属性class: 不检查原型链
       class属性: 记录对象创建时的最初类型名
       如何访问: Object.prototype.toString.call(obj)
       判断: Object.prototype.toString.call(obj)
		=="[object Array]"
                           class
       问题: class仅保留创建时的类型，不反应继承关系
            如果判断返回true：只能说明obj本身就是数组
            如果obj本身不是数组，但继承自数组: 会返回false
    4. 使用新API: Array.isArray(obj) 不检查原型链
         原理: isArray内部使用的就是:	    Object.prototype.toString.call(obj)

    多态: 同一类型的对象或父子对象之间都存在着差异
    如何使用: 
	重写(override)：子对象觉得从父对象继承来的成员不好用，可在本地定义同名自有成员，覆盖父对象的成员
        
正课:
1. *****面向对象:
   自定义继承: 3种: 
    1. 直接设置两个对象间的继承关系: 
       子对象.__proto__=父对象 //内部属性，可能被禁用
       Object.setPrototypeOf(子对象，父对象)
       让子对象继承父对象
    2. 直接修改构造函数的原型对象，实现批量修改子对象的父对象
       时机: 在定义完构造函数后，为原型对象添加共有属性前，立刻更改原型对象
       构造函数.prototype=父对象
*****3. 即继承原型，又扩展结构: 最像Java的继承
        其实是两个类型间的继承
       继承(inherit): 子类型的原型继承父类型的原型
       扩展(extends): 子类型的构造函数调用了父类型的构造函数并扩展了新的属性。
      如何实现: 2步: 
        1. 在子类型构造函数内调用父类型的构造函数
           父类型构造函数.apply(this,arguments)
    *****call 和 apply
            相同: 借用函数，并更换调用时的this为指定对象
            不同: call要求传入的参数必须单独传入
                  apply要求传入的参数必须以数组方式整体传入
  
        2. 让子类型构造函数的原型，继承父类型构造函数的原型
           Object.setPrototypeOf(
	       子类型构造函数的原型，
               父类型构造函数的原型
	   )

正课: 
1. ECMAScript5.0
   1. 对象:
     对象的本质: 属性的集合
     对象的属性: 
       命名属性: 可直接通过.访问到的属性
         数据属性: 专门保存一个值的属性
         访问器属性: 保护数据属性的特殊属性
       内部属性: 不能通过.直接访问的属性
         比如: class   __proto__

     数据属性: 4大特性: 描述属性的配置信息
       value: 实际存储属性值的特性
       writable: 定义了当前属性是否可修改
                默认true
                如果改为false，当前属性变为只读
       enumerable: 定义能否被for in遍历到
                默认true
                如果改为false，当前属性在for in时不会被遍历
                但是，使用.依然可正常访问
       configurable: 定义了属性能否被删除或能否修改其他特性
                默认true
                如果改为false，不能删除当前属性
                             也不能修改当前属性的其他特性
                          ***不可逆

     如何获取四大特性:
       var 数性描述对象=
	Object.getOwnPropertyDescriptor(obj,"属性名");
     如何修改四大特性: 
       Object.defineProperty(obj,"属性名",{
           需要修改的特性
       }) 
       特例: 如果obj中包含指定属性，则修改现有属性的值
            如果obj中不包含指定属性，则在obj中自动添加新属性

     特性的默认值: 
       1. 属性在创建对象时就定义好了：所有特性的默认值都为true
       2. 使用defineProperty添加的属性，特性的默认值都为false
          所以，在使用defineProperty添加属性时，必须显式定义属性的特性为true，否则默认都为false

     访问器属性: 
       getter/setter访问器: 两个专门操作1个变量的方法
          其中get方法负责读取变量的值
              set方法负责修改变量的值
       四大特性:
         get:function(){return 局部变量的值;}
         set:function(value){
           先验证value是否符合要求
	     局部变量=value;
         }
         enumerable:
         configurable:
       如何定义访问器属性: 
          Object.defineProperty(obj,"属性名",{
              访问器属性的四大特性
          })
       何时调用get/set： 
          试图通过访问器属性取值时，自动调用get特性的函数
          试图通过访问器属性设置值时，自动调用set特性的函数
              一般在set中设置对要设置的新值得验证
       	  特殊: 如果省略set特性，则该属性为只读

    2. Object.create(): 基于指定父对象，创建并扩展子对象
         做3件事: 1. 创建一个新对象
                  2. 设置新对象继承父对象
                  3. 为新对象扩展新属性
         何时使用: 只要基于现有的父对象，创建并扩展一个新的子对象时。
         如何使用: var son=Object.create(father,{
                      新属性:{属性的四大特性},
                      ...:{...}
                   });
回顾:
1. ES5标准：
   对象: 
    对象属性:
      命名属性:
          数据属性: 专门存储数据的属性
              四大特性: {
                value:值,
                writable:true/false,
                enumerable:true/false,
                configurable:true/false //一旦改为false不可逆
              }
        访问器属性: 专门保护数据属性的特殊属性，不实际存储数据
              四大特性:{
                get:function(){return 局部变量},
                set:function(value){局部变量=value},
                enumerable:同数据属性
                configurable:同数据属性
              }
           强调: 使用访问器属性，必须有一个受保护的局部变量
                 都要通过闭包来添加访问器属性: 
            单独添加访问器属性:
            (function(){
                var 局部变量=值;
                Object.defineProperty(obj,"属性名",{
		    get:function(){return 局部变量},
                    set:function(value){局部变量=value},
                    enumerable:true, configurable:true
                })
            })();
            在构造函数中添加访问器属性:
            function(属性参数){
                this.公有属性=参数,
                ...
                Object.defineProperty(obj,"属性名",{
		    get:function(){return 属性参数},
                    set:function(value){属性参数=value},
                    enumerable:true, configurable:true
                })
            }
        定义命名属性: 
           1. 只定义一个命名属性: 
	        Object.defineProperty(obj,"属性名",{
                    四大特性
                })
           2. 同时定义多个属性:
                Object.defineProperties(obj,{
                    属性名1:{
			四大特性
 		    },
                    ...:{...}
                })
           如果指定名称的属性存在，则修改现有属性
           如果指定名称的属性不存在，则自动创建同名属性
           默认值: 非defineProperty定义的属性，四大特性默认值都是true。
                   defineProperty添加的属性，四大特性默认值都是false。
	   何时修改四大特性: 只要保护属性，就用四大特性控制
               何时使用数据属性: 只想控制只读，遍历或删除
               何时使用访问器属性: 希望用自定义逻辑保护变量
      内部属性:

    Object.create(): 基于现有父对象，创建新对象，继承父对象，同时可为新对象扩展新属性。
      3件事： 1. 创建新对象
              2. 设置新对象继承指定父对象
              3. 为新对象扩展新属性
      实现继承: 4种:
        1. 仅修改两个对象间的继承:
           Object.setPrototypeOf(子，父)
        2. 修改所有子对象的父对象: 修改构造函数的原型对象
           时机: 定义完构造函数后，立刻修改
           构造函数.prototype=父
        3. 两种类型间的继承。即继承原型(inherit)，又扩展结构(extends): 最像Java的继承。
           2步:
            1. extends: 在子类型构造函数开始位置，借用父类型构造函数
               父类型构造函数.apply(this,arguments)                        2. inherit: 设置子类型构造函数的原型继承父类型构造函数的原型
               Object.setPrototypeOf(
                   子类型构造函数.prototype,
                   父类型构造函数.prototype
               )      
        4. 基于现有父对象，创建并扩展一个新的子对象:
           var son=Object.create(parent,{同defineProperties})
      强调: 第二个参数的属性特性定义时，默认所有特性都为false
            建议: 使用Object.create时，都要显示定义所有值为true的特性。

    Object.create(parent) vs Object.clone(org):
         create: 新对象继承parent
                 新对象不会复制parent的属性
         clone: 新对象和org之间没有继承关系
                新对象会复制parent的属性保存在新对象本地

正课:
1. ES5:
   对象：
     防篡改
   函数API: bind方法
   数组API: 
   严格模式: 

1. 防篡改: 创建对象后，限制对对象的修改
     3个级别: 
     1. 禁止扩展: 
        extensible: 内部,控制能否给对象添加新属性
           默认: true,可添加新属性
        获取extensible的值: Object.isExtensible(obj)
                        用于检查obj能否扩展
        禁止扩展: Object.preventExtensions(obj)
              禁止obj后续添加新属性（extensible=false）
     2. 密封: 在禁止扩展的基础上,将所有属性的configurable设置为false。
        Object.issealed(obj)判断obj是否被密封
        Object.seal(obj) 密封obj
       chrome中特例: 依然可修改其它特性。
     3. 冻结: 在密封基础上，禁止修改属性的值
        Object.isFrozen(obj) 判断obj是否被冻结
        Object.freeze(obj) 冻结一个对象

     都不可逆！

2. 数组API: 迭代方法: 依次对数组中每个元素执行相同的操作
     3大类: 
     1.判断: 
       1. 数组的所有元素，是否都符合要求
          var bool=arr.every(function(val,idx,arr){
	      return 判断条件
	  })
          其中:val 当前元素的值
               idx 当前元素的下标i
               arr 当前数组
          所有元素都返回true时，才返回true
          只要一个元素返回false，就返回false
       2. 数组中是否包含符合要求的元素
          var bool=arr.some(function(val,idx,arr){
	      return 判断条件
	  })
          只要一个元素返回true，就返回true
          除非所有元素都返回false，才返回false
    2. 遍历: 
      1. forEach: 
	对原数组中每个元素执行相同操作，直接修改原数组
      2. map:
        对原数组中每个元素的值执行相同的操作，再生成新数组
        原数组元素保持不变

正课
1. ES5:
   数组API:
   bind:
   严格模式: 

1. 数组API: 
   过滤和汇总:
   过滤: 从数组中筛选出符合条件的元素，组成新数组
     var sub=arr.filter(function(val,idx,arr){
	return 判断条件
     });
     只有符合判断条件的元素，才放入新数组sub中
     原数组不变。

   汇总: 依次将数组中每个元素的值，汇总出一个最后结果
     var result=arr.reduce(function(prev,val,idx,arr){
	return prev和val汇总的结果
     },base)
     其中: prev是目前为止的汇总值
           base表示初始值

2. bind: 
   call apply bind
   call vs apply:
     相同: 借用函数，并更改函数调用时的this为指定对象
     不同: 第二个参数: 
         call, 所有参数必须单独传入
         apply，所有参数必须放在一个数组内整体传入
                apply再自动打散数组，将参数传递给函数

   bind: 基于现有函数，创建一个新函数，提前将替换this的对象，绑定给新函数。
   何时使用: 基于现有函数，创建一个新函数
             并提前永久绑定this，和部分参数值时
   vs call/apply: 都是替换this
     不同: call/apply：借用: this都是临时替换
                       *调用*: 
           bind: 永久绑定this
                 为指定对象*创建*一个专属的函数副本。
   如何使用:
     1. 仅将newFun中的this绑定为obj:var newFun=fun.bind(obj);
     2. 同时给newFun提前绑定this和个别参数:
          var newFun=fun.bind(obj,param1,...);
          仅绑定部分参数。
          剩余参数需要在调用时动态传入:
          newFun(剩余参数值);

3. 严格模式:
    启用严格模式： 2个范围:
     1. 整个<script>范围内都采用严格模式:
        在<script>的顶部写: "use strict";
        何时使用: 新开发的项目，建议全用严格模式
     2. 仅在一个函数内使用严格模式: 
        在函数定义的顶部: "use strict"
        何时使用: 维护旧的项目，逐个函数向严格模式迁移
    规定: 
    1. 不允许对未声明的变量赋值
    2. 将静默失败升级为错误
    3. 严格模式下新增eval作用域: eval内声明的变量，eval结束后无法使用。
    4. 匿名函数自调中arguments.callee失效
         意味着: 匿名函数不再允许递归调用
     

















