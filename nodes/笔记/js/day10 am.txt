回顾:
1. ES5标准：
   对象: 
    对象属性:
      命名属性:
          数据属性: 专门存储数据的属性
              四大特性: {
                value:值,
                writable:true/false,
                enumerable:true/false,
                configurable:true/false //一旦改为false不可逆
              }
        访问器属性: 专门保护数据属性的特殊属性，不实际存储数据
              四大特性:{
                get:function(){return 局部变量},
                set:function(value){局部变量=value},
                enumerable:同数据属性
                configurable:同数据属性
              }
           强调: 使用访问器属性，必须有一个受保护的局部变量
                 都要通过闭包来添加访问器属性: 
            单独添加访问器属性:
            (function(){
                var 局部变量=值;
                Object.defineProperty(obj,"属性名",{
		    get:function(){return 局部变量},
                    set:function(value){局部变量=value},
                    enumerable:true, configurable:true
                })
            })();
            在构造函数中添加访问器属性:
            function(属性参数){
                this.公有属性=参数,
                ...
                Object.defineProperty(obj,"属性名",{
		    get:function(){return 属性参数},
                    set:function(value){属性参数=value},
                    enumerable:true, configurable:true
                })
            }
        定义命名属性: 
           1. 只定义一个命名属性: 
	        Object.defineProperty(obj,"属性名",{
                    四大特性
                })
           2. 同时定义多个属性:
                Object.defineProperties(obj,{
                    属性名1:{
			四大特性
 		    },
                    ...:{...}
                })
           如果指定名称的属性存在，则修改现有属性
           如果指定名称的属性不存在，则自动创建同名属性
           默认值: 非defineProperty定义的属性，四大特性默认值都是true。
                   defineProperty添加的属性，四大特性默认值都是false。
	   何时修改四大特性: 只要保护属性，就用四大特性控制
               何时使用数据属性: 只想控制只读，遍历或删除
               何时使用访问器属性: 希望用自定义逻辑保护变量
      内部属性:

    Object.create(): 基于现有父对象，创建新对象，继承父对象，同时可为新对象扩展新属性。
      3件事： 1. 创建新对象
              2. 设置新对象继承指定父对象
              3. 为新对象扩展新属性
      实现继承: 4种:
        1. 仅修改两个对象间的继承:
           Object.setPrototypeOf(子，父)
        2. 修改所有子对象的父对象: 修改构造函数的原型对象
           时机: 定义完构造函数后，立刻修改
           构造函数.prototype=父
        3. 两种类型间的继承。即继承原型(inherit)，又扩展结构(extends): 最像Java的继承。
           2步:
            1. extends: 在子类型构造函数开始位置，借用父类型构造函数
               父类型构造函数.apply(this,arguments)                        2. inherit: 设置子类型构造函数的原型继承父类型构造函数的原型
               Object.setPrototypeOf(
                   子类型构造函数.prototype,
                   父类型构造函数.prototype
               )      
        4. 基于现有父对象，创建并扩展一个新的子对象:
           var son=Object.create(parent,{同defineProperties})
      强调: 第二个参数的属性特性定义时，默认所有特性都为false
            建议: 使用Object.create时，都要显示定义所有值为true的特性。

    Object.create(parent) vs Object.clone(org):
         create: 新对象继承parent
                 新对象不会复制parent的属性
         clone: 新对象和org之间没有继承关系
                新对象会复制parent的属性保存在新对象本地

正课:
1. ES5:
   对象：
     防篡改
   函数API: bind方法
   数组API: 
   严格模式: 

1. 防篡改: 创建对象后，限制对对象的修改
     3个级别: 
     1. 禁止扩展: 
        extensible: 内部,控制能否给对象添加新属性
           默认: true,可添加新属性
        获取extensible的值: Object.isExtensible(obj)
                        用于检查obj能否扩展
        禁止扩展: Object.preventExtensions(obj)
              禁止obj后续添加新属性（extensible=false）
     2. 密封: 在禁止扩展的基础上,将所有属性的configurable设置为false。
        Object.issealed(obj)判断obj是否被密封
        Object.seal(obj) 密封obj
       chrome中特例: 依然可修改其它特性。
     3. 冻结: 在密封基础上，禁止修改属性的值
        Object.isFrozen(obj) 判断obj是否被冻结
        Object.freeze(obj) 冻结一个对象

     都不可逆！

2. 数组API: 迭代方法: 依次对数组中每个元素执行相同的操作
     3大类: 
     1.判断: 
       1. 数组的所有元素，是否都符合要求
          var bool=arr.every(function(val,idx,arr){
	      return 判断条件
	  })
          其中:val 当前元素的值
               idx 当前元素的下标i
               arr 当前数组
          所有元素都返回true时，才返回true
          只要一个元素返回false，就返回false
       2. 数组中是否包含符合要求的元素
          var bool=arr.some(function(val,idx,arr){
	      return 判断条件
	  })
          只要一个元素返回true，就返回true
          除非所有元素都返回false，才返回false
    2. 遍历: 
      1. forEach: 
	对原数组中每个元素执行相同操作，直接修改原数组
      2. map:
        对原数组中每个元素的值执行相同的操作，再生成新数组
        原数组元素保持不变











