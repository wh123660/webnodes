正课: 
1. *****面向对象:
   *****原型和原型链
   *****继承

1. *****面向对象: 
   面向对象三大特点: 
      封装：将事物的属性和功能集中定义在一个对象中
      继承：父对象的成员，子对象不用反复创建，也可直接使用
      多态：同一类事物或父子关系的事物，也可能表现出不同的状态

   js中都是继承原型:
   原型对象: 集中保存一类对象共有成员的父级对象
   何时使用原型对象: 凡是所有子对象共有的属性*值*和方法，都要在原型中集中定义一次。子对象共同使用。
   如何使用: 
      如何获得原型对象: 每个函数都有一个prototype属性引用自己的原型对象。
   回顾: new 4件事: 
        1. 创建空对象
        2. 设置空对象的__proto__属性继承构造函数的原型对象
            原型对象中的属性，新对象可直接使用，不用重复定义
        3. 调用构造函数为新对象添加属性和方法
        4. 返回新对象地址保存在变量中
      如何向原型对象中添加共有属性和方法: 
        构造函数.prototype.属性名/方法名=....

   原型链: 由各级对象的__proto__属性连续继承形成的链式结构
       用来控制属性的使用顺序: 自己有，就不用父级的。
                               自己没有，才到父级找。
                             如果父级没有，继续延原型链向上找
                        如果到顶级对象都没有，才返回undefined
       vs 作用域链: 用于控制变量的使用顺序。

   自有属性和共有属性: 
     1. 判断自有属性: var bool=obj.hasOwnProperty("属性名");
        如果指定"属性"，直接保存在obj本地，则是自有属性，返回true。
        如果指定"属性"，没有保存在obj本地，则返回false。
     2. 判断共有属性: 不是自有，且在原型链中有
          !obj.hasOwnProperty("属性名")
          &&("属性名" in obj)//判断obj的原型链上是否包含指定属性。

   内置对象的原型对象: 保存了内置对象共有的API和属性值

   原型相关API: 
     1. 获得对象的父级原型对象: 2种:
       1. 通过构造函数获得: 构造函数.prototype
       2. 通过子对象获得: 
	obj.__proto__ 问题: __proto__是内部属性，可能被禁用
        Object.getPrototypeOf(obj)
     2. 判断两对象间的父子关系:
       父对象.isPrototypeOf(子对象)
         如果父对象确实是子对象的父级，就返回true
         如果父对象不是子对象的父级，就返回false
       强调: 检查整个原型链

   重写（override）: 如果子对象觉得父对象的成员你不好用，可在本地定义同名成员覆盖父对象成员








