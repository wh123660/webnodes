回顾: 
1. ***String
   1. 大小写转换: str.toUpperCase();
                  str.toLowerCase();
   2. 获取指定位置字符: str.charAt(i);
                  var unicode=str.charCodeAt(i) 
                  var char=String.fromCharCode(unicode)
   3. 获取子字符串:
        str.slice(starti,endi+1);
        str.substring(starti,endi+1);
        str.substr(starti,n);
   4. 检索关键词: 
        1. 检索一个固定的关键词:
             var i=str.indexOf("关键词",fromi);
                   str.lastIndexOf("关键词",fromi);
        2. 检查有没有: var i=str.search(reg);
        3. 获得所有关键词的内容: 
	    var arr=str.match(reg);//reg一定要加g
        4. 即找每个关键词的内容，又找位置:
            var arr=reg.exec(str)
   5. 替换: 删除和格式化
       str.replace(reg,"替换值");
       str.replace(reg,function(kword,$1,$2,....){
	    return 处理后的替换值;
	});
      删除: 将关键词替换为""
      格式化: 2步: 
          Step1. 用正则将关键词分组
          Step2. 在replace的第二个参数中用$n，重新拼接新的格式
              $n 正则中第n个()匹配的子关键词
    6. 切割: var subs=str.split(reg);
         固定套路:将字符串打散为字符数组: 
		var chars=str.split("");

2. *****正则表达式:
   1. 最简单的正则表达式: 关键词原文
   2. 字符集: [备选字符列表]
	如果字符列表部分连续: 可用-省略中间字符
        如果表示除了个别字符: [^xxx]
   3. 备选字符集:
        一位数字 \d  一位字母数组或下划线: \w
        一位空字符 \s  任意一个字符: .
   4. 量词:
        有明确数量: 
          字符集{m,n}  至少m次，最多n次
          字符集{m,} 至少m次，多了不限
          字符集{m}  必须m次，不能多不能少
        没有明确数量: 
          字符集?  可有可无，最多一次
          字符集*  可有可无，多了不限
          字符集+  至少一次，多了不限
   5. 选择和分组: 
      选择: 或 |
      分组: () 每个分组在匹配时，自动获得一个序号，从1开始
           2种用途: 1. 在正则内部\n，匹配和第n个分组相同的内容
                    2. js中使用$n获得关键词的第n个分组子关键词
   6. 指定匹配位置: 
      ^: 字符串的开始位置
      $: 字符串的结束位置
      \b: 单词边界, 默认仅匹配一边。
	如果匹配独立单词，要两边同时加\b
      
   密码强度: 8位字母数字的组合，至少包含一位大写字母和一位数字
       1. 不都是字母: 至少有一个数字或特殊符号
         (?![a-zA-Z]+$)
       2. 不都是小写子母和数字: 至少有一个大写字母或特殊符号
         (?![a-z0-9]+$)
       3. 只能由字母和数字组成:
         [a-zA-Z0-9]{8}
       结果： ^(?![a-zA-Z]+$)(?![a-z0-9]+$)[a-zA-Z0-9]{8}$

正课:
1. ***RegExp:
2. Math:
3. *Date:

1. ***RegExp: 专门封装一个正则表达式，提供用正则表达式执行查找和验证的API  的对象
    1. 创建: 
	1. 直接量: var reg=/正则/ig;
	   何时使用: 如果正则是固定的，不需要动态拼接
           转义: 如果包含/,都要转为\/
        2. 使用new关键字: var reg=new RegExp("正则"[,"ig"]);
           何时使用: 如果正则不是现成的，需要运行时拼接
           转义: 如果包含"或'，都要转为\"和\'
                 如果包含\d,\w,\s，必须写成\\d,\\w,\\s
    2. API:
      1. 查找关键词：查找每个关键词的内容和位置
        var arr=reg.exec(str);
          意为: 在str中查找下*一个*和reg匹配的关键词
          返回值: arr: [kword,$1,$2,...]
                          0
                  arr.index: 保存了本次找到的关键词的位置
              如果没找到返回null
          原理: 默认从开头查找下一个关键词
              如果找到，就将将关键词保存在结果数组的第一个元素
              将关键词位置保存在结果数组的index属性中
            exec自动将reg的lastIndex调整到本次找到的关键词之后
                reg.lastIndex： 标识正则下次匹配的开始位置
       课堂练习: 
         贪婪模式: 正则表达式默认匹配最长的符合条件的字符串
	     比如: .* .+
         懒惰模式: 让正则仅匹配最短的符合条件的字符串
             贪婪->懒惰: (.*?) (.+?)
         















